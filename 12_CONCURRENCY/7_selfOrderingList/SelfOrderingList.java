// cd ~/Desktop/ALL_POOLED/COMPUTING/CODING/JavaExercises/12_CONCURRENCY/7_selfOrderingList// Exercise 17.7: Introduction to concurrency/*One of the advantages of using threads in some applications is that they allow programmersto do costly operations in the background when nobody is looking.For example, a self-sorting list can reorder itself in between calls to minimise the timeneeded to add elements (e.g. in applications where elements are added in big batches, butconsulted only rarely).Hint: For this exercise, it may be easier to create your own dynamic list instead ofrelying on those from the Java Collections Library. Remember that the latter are notthread-safe, i.e. they are not properly synchronised, so they require externalsynchronisation.((So my reading into this statement is that there must be a pausein the adding function in order for the sorting functionality to wake up and do its thing.The adding and sorting are not to happen in parallel but are synchronous, each waits forthe other to finish. So adding must be also be delayed until sorting is finished. But thisseems a bit rubbish to me. Surely, you'd want the adding to be able to continue withouthaving to wait for sorting to finish..?))7.1.Create a list of Integer that keeps itself sorted by sorting itself when othersare not looking. The list must have at least methods add(Integer) (to add newIntegers) and get(int) (to get the ith integer in the (sorted) list).• The add() method must add the new element at the end of the list, mark the list as“not sorted” and return immediately.• Another thread must be always observing the list and checking whether it is sorted;if it is, it must mark it as “sorted”; if it is not, the thread must sort it. Thethread must re-order the list in small steps to make sure it does not cause additionaldelay when new elements are added to the list while it is sorting itself (i.e. do notinclude a long loop in your synchronised code that may block the addition of newelements for a long time).• The method get(int) must always return the ith integer in the (sorted) list; if thismethod is called while the list is “not sorted”, the list must be fully sorted beforeit can return; no additional elements can be added until the call of get(int) returns.7.2.Create another self-ordering list in which the add() method launches a new threadwhose only purpose is to add the new integer at the right position. (Hint: if the newelement has to be placed at the beginning of the list, there is no need to launch athread only for that).((not sure if I can instruct a thread to wait from another thread. i.e. otherThread.wait()))*/public class SelfOrderingList {  private IntegerNode rootNode;  private boolean mightBeUnsorted;//because new integer(s) added so it may or may not be unsorted.  private boolean activelyAdding;// these are acting a bit like semaphores or something..??  private boolean activelySorting;// these are acting a bit like semaphores or something..??  private SelfOrderingList sol;  public SelfOrderingList() {    rootNode = null;    mightBeUnsorted = false;    activelyAdding = false;  }  public static void main(String[] args) {    SelfOrderingList sol = new SelfOrderingList();    SelfOrderingList.IntegerNode list = sol.new IntegerNode();    SelfOrderingList.CheckingAndSortingThread nestedSorter = sol.new SortingThread();    Thread thread = new Thread(nestedSorter);    thread.start();    list.add(3);    list.add(8);    System.out.println("printing out here. (It also provides short delay in which sorting can occur). List is: "+sol.printOut());    list.add(1);    list.add(9);    list.add(4);    System.out.println("printing out here. (It also provides short delay in which sorting can occur). List is: "+sol.printOut());    list.add(6);    list.add(23);    list.add(64);    System.out.println("printing out here. (It also provides short delay in which sorting can occur). List is: "+sol.printOut());    list.add(2);    list.add(5);  }  /**  *  */  public void add(int number) {    activelyAdding = true;    if (rootNode == null) {      rootNode = new IntegerNode(number);      activelyAdding = false;    } else {      rootNode.addToEnd(number);      }    }    /**    *    */    private synchronized void addToEnd(int number) {      if (nextNode == null) {          nextNode = new IntegerNode(number);          IntegerNode currentNode = this;          currentNode = nextNode.previousNode;      } else {        nextNode.addToEnd(number);      }      mightBeUnsorted = false;      activelyAdding = false;    }  /**  *  */  private class CheckingAndSortingThread implements Runnable {    public void run() {      while (true) { //always actively checking the list        if (mightBeUnsorted) {          sortUnsortedListIfNotActivelyAddingToList();        }      }    }    /**    *    */    public void sortUnsortedListIfNotActivelyAddingToList() {      IntegerNode currentNode = null;      if (rootNode != null) {        currentNode = rootNode;      }      while (mightBeUnsorted && currentNode.nextNode != null) {        if (activelyAdding) {          try {            Thread.sleep(10);          } catch (InterruptedException e) {            printStackTrace();          }        } else if (currentNode.number > currentNode.nextNode.number) {          currentNode.nextNode.nextNode.previousNode = currentNode;          currentNode.previousNode = currentNode.nextNode;          currentNode.nextNode.nextNode = currentNode;          if (currentNode != rootNode) {            currentNode.nextNode.previousNode = currentNode.previousNode;          } else {            currentNode.nextNode.previousNode = null;            rootNode = currentNode.nextNode;          }        } else {          currentNode = currentNode.nextNode;        }      }      mightBeUnsorted = false;    }  }  /**  * Gets the ith integer  */  public IntegerNode getNodeWithIndex(int indexOfNodeToReturn) {    IntegerNode nodeToReturn = null;    int rootIndexNumber = 0;    try {      if (rootNode == null) {        throw new IllegalArgumentException("the list is empty, cannot get any nodes");      }      if (indexOfNodeToReturn == rootIndexNumber) {        nodeToReturn = rootNode;      } else {        nodeToReturn = rootNode.getNodeWithIndex(rootIndexNumber, indexOfNodeToReturn);      }    } catch (IllegalArgumentException e) {      System.out.println(e.getMessage());    }    return nodeToReturn;  }  /**  * Nested class  */  private class IntegerNode {    private IntegerNode nextNode;    private IntegerNode previousNode;    private int number = 0;    private IntegerNode(int number) {      nextNode = previousNode = null;      this.number = number;    }    public boolean checkIfListIsUnsorted() {      if (mightBeUnsorted && rootNode != null) {        return checkIfListIsUnsorted();      } else {        return mightBeUnsorted = false;      }    }    /**    *    */    private IntegerNode getNodeWithIndex(int currentIndexNumber, int indexOfNodeToReturn) {      IntegerNode nodeToReturn = null;      if (currentIndexNumber + 1 == indexOfNodeToReturn) {        nodeToReturn = nextNode;      } else {        nextNode.getNodeWithIndex(currentIndexNumber + 1, indexOfNodeToReturn);      }      return nodeToReturn;    }  }}