// cd ~/Desktop/ALL_POOLED/COMPUTING/CODING/JavaExercises/12_CONCURRENCY/7_selfOrderingList// Exercise 17.7: Introduction to concurrency/*One of the advantages of using threads in some applications is that they allow programmersto do costly operations in the background when nobody is looking.For example, a self-sorting list can reorder itself in between calls to minimise the timeneeded to add elements (e.g. in applications where elements are added in big batches, butconsulted only rarely).Hint: For this exercise, it may be easier to create your own dynamic list instead ofrelying on those from the Java Collections Library. Remember that the latter are notthread-safe, i.e. they are not properly synchronised, so they require externalsynchronisation.7.1Create a list of Integer that keeps itself sorted by sorting itself when others arenot looking. The list must have at least methods add(Integer) (to add new Integers)and get(int) (to get the ith integer in the (sorted) list).• The add() method must add the new element at the end of the list, mark the list as“not sorted” and return immediately.• Another thread must be always observing the list and checking whether it is sorted;if it is, it must mark it as “sorted”; if it is not, the thread must sort it. Thethread must re-order the list in small steps to make sure it does not cause additionaldelay when new elements are added to the list while it is sorting itself (i.e. do notinclude a long loop in your synchronised code that may block the addition of newelements for a long time).• The method get(int) must always return the ith integer in the (sorted) list; if thismethod is called while the list is “not sorted”, the list must be fully sorted beforeit can return; no additional elements can be added until the call of get(int) returns.7.2Create another self-ordering list in which the add() method launches a new threadwhose only purpose is to add the new integer at the right position. (Hint: if the newelement has to be placed at the beginning of the list, there is no need to launch athread only for that).*/public class SelfOrderingList {  private IntegerNode root;  private boolean sorted;  public static void main(String[] args) {    SelfOrderingList sol = new SelfOrderingList();    SelfOrderingList.AddingClass ac = sol.new AddingClass();    Thread t1 = new Thread(ac);    t1.start();    SelfOrderingList.SortingClass sc = sol.new SortingClass();    Thread t2 = new Thread(sc);    t2.start();    System.out.println(sol.getNodeWithIndex(0).number);    System.out.println(sol.getNodeWithIndex(1).number);    System.out.println(sol.getNodeWithIndex(0).number);    System.out.println(sol.getNodeWithIndex(1).number);    System.out.println(sol.getNodeWithIndex(0).number);    System.out.println(sol.getNodeWithIndex(1).number);  }  public SelfOrderingList() {    root = null;    sorted = true;  }  private class AddingClass implements Runnable {    public void run() {      add(3);      add(8);      add(1);      add(9);      add(4);      add(6);      add(23);      add(64);      add(2);      add(5);    }  }  private class SortingClass implements Runnable {    public void run() {      while (!sorted) {        root.checkAndSort();      }    }  }  public void add(Integer number) {    if (root == null) {      root = new IntegerNode(number);    } else {      root.add(number);    }  }  /**  * Gets the ith integer  */  public IntegerNode getNodeWithIndex(int indexOfNodeToReturn) {    IntegerNode nodeToReturn = null;    int rootIndexNumber = 0;    try {      if (root == null) {        throw new IllegalArgumentException("the list is empty, cannot get any nodes");      }      if (indexOfNodeToReturn == rootIndexNumber) {        nodeToReturn = root;      } else {        nodeToReturn = root.getNodeWithIndex(rootIndexNumber, indexOfNodeToReturn);      }    } catch (IllegalArgumentException e) {      System.out.println(e.getMessage());    }    return nodeToReturn;  }  /**  * Nested class  */  private class IntegerNode {    private IntegerNode next;    private IntegerNode previous;    private int number = 0;    private IntegerNode(int number) {      next = previous = null;      this.number = number;    }    public void checkAndSort() {      while (!sorted) {        if (next == null) {          sorted = true;          return;        } else if (this.number > next.number) {System.out.println("this.number > next.number is yes ");          synchronized (this) {System.out.println("this.number is: " + this.number);            if (this == root) {              root = next;            }            if (next.next != null) {              next.next.previous = this;            }            next.previous = previous;            previous = next;            next = next.next;            previous.next = this;          }/*          try {            wait();          } catch (InterruptedException ex) {  		        // Nothing to do, just sleep less          }*/        } else {          next.checkAndSort();        }      }    }    private synchronized void add(int number) {      if (next == null) {          next = new IntegerNode(number);          IntegerNode currentNode = this;          currentNode = next.previous;          sorted = false;      } else {        next.add(number);      }      sorted = false;      notifyAll();    }    private IntegerNode getNodeWithIndex(int currentIndexNumber, int indexOfNodeToReturn) {      IntegerNode nodeToReturn = null;      if (currentIndexNumber + 1 == indexOfNodeToReturn) {        nodeToReturn = next;      } else {        next.getNodeWithIndex(currentIndexNumber + 1, indexOfNodeToReturn);      }      return nodeToReturn;    }  }}