// cd ~/Desktop/ALL_POOLED/COMPUTING/CODING/JavaExercises/05_DATA_STRUCTURES/TREES// Exercise 9.4. (Introduction to Trees, Sets, interfaces, sorted & unsorted lists)/*'Abstract syntax tree'When a computer reads a mathematical expression (or a program), the first step inunderstanding it is creating a tree representation.The nodes contain the operations and the leaves contain the operands.Create a binary tree node class, where each node contains a String.Apart from the usual add(String) and toString() methods, add a static method thattakes a mathematical expression as a String and returns a tree that representsthe mathematical expression.*/import java.util.List;import java.util.ArrayList;public class AbstractSyntaxTree {  private ASTNode root;  private List<ASTNode> subsetEquations;  public static void main(String[] args) {    buildAbstractSyntaxTree("1 + 1 - 15 / (3 * 5)");  }  /**  * If string at the specified position in the specified list is an operator,  * creates a node and  for the operators and makes nodes for the operators' child nodes.  */  public void add(String[] equationList, int position, int parenthesisLevel) {    ASTNode newNode = null;    subsetEquations = new ArrayList<>();    if (isOperator(equationList[position])) {      newNode = new ASTNode(equationList[position], parenthesisLevel);      newNode.leftChild = new ASTNode(equationList[position - 1], parenthesisLevel);      newNode.leftChild.isALeftChildOf = newNode;      newNode.rightChild = new ASTNode(equationList[position + 1], parenthesisLevel);      newNode.rightChild.isARightChildOf = newNode;System.out.println("newNode: " + newNode);      subsetEquations.add(newNode);System.out.println("subsetEquations.get(0): " + subsetEquations.get(0));    }//System.out.println("subsetEquations.get(0): " + subsetEquations.get(0) + " should be same as 1st new Node: " + newNode);  }  /**  * Builds the abstract syntax tree of the specified equation.  * Converts the equation into a list of operators and operands,  * records the parentheses, calls add to store the operators in another list.  */  public static void buildAbstractSyntaxTree(String equation) {    String equation_ = equation.trim();    String[] equationList = equation_.split(" ");    AbstractSyntaxTree astTree = new AbstractSyntaxTree();    int i = 0;    boolean subsetEquationsListIncomplete = true;    int parenthesisLevel = 0;    while (i != equationList.length) {      if (equationList[i].substring(0,1).equals("(")) {        parenthesisLevel++;      } else if (equationList[i].substring(equationList[i].length() - 1).equals(")")) {        parenthesisLevel--;      }      astTree.add(equationList, i, parenthesisLevel);      i++;    }System.out.println("root before calling setRootFromSubsetEquations() should be null: " + astTree.root);    astTree.setRootFromSubsetEquations();System.out.println("root after calling setRootFromSubsetEquations()");    if (astTree.root.leftChild.isARightChildOf != null) {      astTree.root.leftChild = astTree.root.leftChild.isARightChildOf;      astTree.root.leftChild.buildTreeToLeft();    }    if (astTree.root.rightChild.isALeftChildOf != null) {      astTree.root.rightChild = astTree.root.rightChild.isALeftChildOf;      astTree.root.rightChild.buildTreeToRight();    }  }  /**  * Returns true specified string is a number. Done using using regular expression.  * (http://stackoverflow.com/questions/1102891/how-to-check-if-a-string-is-a-numeric-type-in-java)  */  public boolean isNumeric(String operatorOperand) {    return operatorOperand.matches("-?\\d+(\\.\\d+)?");  //match a number with optional '-' and decimal.  }  /**  * Returns true if specified string is an operator.  */  public boolean isOperator(String operatorOperand) {    return operatorOperand.equals("%") || operatorOperand.equals("/") || operatorOperand.equals("*") || operatorOperand.equals("-") || operatorOperand.equals("+");  }  /**  * Returns true if specified node contains an operator.  */  public boolean isOperatorNode(ASTNode node) {    return isOperator(node.operatorOperand);  }  /**  *  */  public void resetRootTo(ASTNode newRoot) {    newRoot.leftChild = root;    root = newRoot;  }  /**  *  */  public void setRootFromSubsetEquations() {    try {      if (subsetEquations.get(0) == null) {        throw new IllegalArgumentException("Problem: cannot set root from subsetEquations if null at index 0");      }      root = subsetEquations.get(0);      for (ASTNode node : subsetEquations) {        if (node.hasPrecedenceOver(root)) {          root = node;        }      }    } catch (IllegalArgumentException e) {      System.out.println(e.getMessage());    }  }  /**  * Will remove the parenthesis from the specified node's operand  */  public void stripParenthesisFromOperandIn(ASTNode node) {    try {      if (isNumeric(node.operatorOperand) || isOperator(node.operatorOperand)) {        throw new IllegalArgumentException("Does not contain a parenthesed operand");      }      if (node.operatorOperand.substring(0, 1).equals("(")) {        node.operatorOperand = node.operatorOperand.substring(1);      } else {        int positionOfClosingParenthesis = node.operatorOperand.length() - 1;        node.operatorOperand = node.operatorOperand.substring(positionOfClosingParenthesis);      }    } catch (IllegalArgumentException e) {      System.out.println(e.getMessage());    }  }  /**  * Node as an inner class  */  private class ASTNode {    private ASTNode rightChild, leftChild;    private String operatorOperand;    private ASTNode isARightChildOf, isALeftChildOf;    private int parenthesisLevel;    private ASTNode(String operatorOperand, int parenthesisLevel) {      rightChild = leftChild = null;      this.operatorOperand = operatorOperand;      this.parenthesisLevel = parenthesisLevel;    }    private void buildTreeToLeft() {    }    private void buildTreeToRight() {    }    private boolean hasPrecedenceOver(ASTNode node) {      boolean hasPrecedence = false;      try {        if (isNumeric(node.operatorOperand) || isNumeric(operatorOperand)) {          throw new IllegalArgumentException("Problem: hasPrecedenceOver(ASTNode) compares operators - it's receiving an operand");        }        if (parenthesisLevel > node.parenthesisLevel) {          hasPrecedence = true;        } else if (parenthesisLevel == node.parenthesisLevel) {          if (!operatorOperand.equals(node.operatorOperand)) {            if (operatorOperand.equals("%")) {              hasPrecedence = true;            } else if (operatorOperand.equals("/") && !node.operatorOperand.equals("%")) {              hasPrecedence = true;            } else if (operatorOperand.equals("*") && (!node.operatorOperand.equals("%") || !node.operatorOperand.equals("/"))) {              hasPrecedence = true;            }          }        }      } catch (IllegalArgumentException e) {        System.out.println(e.getMessage());      }      return hasPrecedence;    }    @Override    public String toString() {      return "";    }  }}