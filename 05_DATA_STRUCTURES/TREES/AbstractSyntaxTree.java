// cd ~/Desktop/ALL_POOLED/COMPUTING/CODING/JavaExercises/05_DATA_STRUCTURES/TREES// Exercise 9.4. (Introduction to Trees, Sets, interfaces, sorted & unsorted lists)/*'Abstract syntax tree'When a computer reads a mathematical expression (or a program), the first step inunderstanding it is creating a tree representation.The nodes contain the operations and the leaves contain the operands.Create a binary tree node class, where each node contains a String.Apart from the usual add(String) and toString() methods, add a static method thattakes a mathematical expression as a String and returns a tree that representsthe mathematical expression.*/import java.util.List;import java.util.ArrayList;public class AbstractSyntaxTree {  private AbstractSyntaxTree.ASTNode root;  private List<ASTNode> subsetEquations;  public static void main(String[] args) {    buildAbstractSyntaxTree("1 + 2 - 15 / (3 * 5)");  }  /**  * If string at the specified position in the specified list is an operator,  * creates a node and  for the operators and makes nodes for the operators' child nodes.  */  public void add(String[] equationList, int position, int parenthesisLevel) {    AbstractSyntaxTree.ASTNode newNode = null;    if (isOperator(equationList[position])) {      newNode = this.new ASTNode(equationList[position], parenthesisLevel);      subsetEquations.add(newNode);      if (position + 1 < equationList.length) {        newNode.rightChild = this.new ASTNode(equationList[position + 1], parenthesisLevel);      }      if (subsetEquations.lastIndexOf(newNode) == 0) {        newNode.leftChild = this.new ASTNode(equationList[position - 1], parenthesisLevel);      } else {        newNode.leftChild = subsetEquations.get(subsetEquations.lastIndexOf(newNode) - 1).rightChild;      }    }  }  /**  * Builds the abstract syntax tree of the specified equation.  * Converts the equation into a list of operators and operands,  * records the parentheses, calls add to store the operators in another list.  */  public static void buildAbstractSyntaxTree(String equation) {    String equation_ = equation.trim();    String[] equationList = equation_.split(" ");    AbstractSyntaxTree astTree = new AbstractSyntaxTree();    astTree.subsetEquations = new ArrayList<>();    int i = 0;    int parenthesisLevel = 0;    while (i != equationList.length) {      if (equationList[i].substring(0,1).equals("(")) {        parenthesisLevel++;      } else if (equationList[i].substring(equationList[i].length() - 1).equals(")")) {        parenthesisLevel--;      }      astTree.add(equationList, i, parenthesisLevel);      i++;    }    astTree.setRoot();    astTree.root.buildTreeFromRoot();  }  /**  * Returns true specified string is a number. Done using using regular expression.  * (http://stackoverflow.com/questions/1102891/how-to-check-if-a-string-is-a-numeric-type-in-java)  */  public boolean isNumeric(String operatorOperand) {    return operatorOperand.matches("-?\\d+(\\.\\d+)?");  //match a number with optional '-' and decimal.  }  /**  * Returns true if specified string is an operator.  */  public boolean isOperator(String operatorOperand) {    return operatorOperand.equals("%") || operatorOperand.equals("/") || operatorOperand.equals("*") || operatorOperand.equals("-") || operatorOperand.equals("+");  }  /**  * Returns true if specified node contains an operator.  */  public boolean isOperatorNode(ASTNode node) {    return isOperator(node.operatorOperand);  }  /**  * Will remove the parenthesis from the specified node's operand  */  public void removeParenthesisFromOperandIn(ASTNode node) {    try {      if (isNumeric(node.operatorOperand) || isOperator(node.operatorOperand)) {        throw new IllegalArgumentException("Does not contain a parenthesed operand");      }      if (node.operatorOperand.substring(0, 1).equals("(")) {        node.operatorOperand = node.operatorOperand.substring(1);      } else {        int positionOfClosingParenthesis = node.operatorOperand.length() - 1;        node.operatorOperand = node.operatorOperand.substring(positionOfClosingParenthesis);      }    } catch (IllegalArgumentException e) {      System.out.println(e.getMessage());    }  }  /**  *  */  public void resetRootTo(ASTNode newRoot) {    newRoot.leftChild = root;    root = newRoot;  }  /**  * Reorders subsetEquations from lowest precedence to highest.  * The operator node with lowest precedence will also be the root.  */  public void setRoot() {    try {      if (subsetEquations.isEmpty()) {        throw new IllegalArgumentException("Problem: cannot set root from subsetEquations if this list is empty");      }      root = subsetEquations.get(0);      for (ASTNode node : subsetEquations) {        if (root.hasPrecedenceOver(node)) {          root = node;        }      }    } catch (IllegalArgumentException e) {      System.out.println(e.getMessage());    }  }  /**  * Node as an inner class  */  private class ASTNode {    private ASTNode rightChild, leftChild;    private String operatorOperand;    private int parenthesisLevel;    private ASTNode(String operatorOperand, int parenthesisLevel) {      rightChild = leftChild = null;      this.operatorOperand = operatorOperand;      this.parenthesisLevel = parenthesisLevel;    }    /**    * Builds tree starting from the root.    */    private void buildTreeFromRoot() {      int position = subsetEquations.lastIndexOf(root);      if (subsetEquations.lastIndexOf(root) != 0) {        buildTreeOn("left");      }      if (subsetEquations.lastIndexOf(root) < subsetEquations.size() - 1) {        buildTreeOn("right");      }    }    /**    * If an operator has precedence over another, then it must go further down the tree.    */    private void buildTreeOn(String direction) {      int thisPosition = subsetEquations.lastIndexOf(this);      if (direction.equals("left")) {        if (this.hasPrecedenceOver(subsetEquations.get(thisPosition - 1))) {          subsetEquations.get(thisPosition - 1).rightChild = this;        } else {          leftChild = subsetEquations.get(thisPosition - 1);        }        if (thisPosition - 1 > 0) {          subsetEquations.get(thisPosition - 1).buildTreeOn("left");        }      } else {//direction "right"        if (this.hasPrecedenceOver(subsetEquations.get(thisPosition + 1))) {          subsetEquations.get(thisPosition + 1).leftChild = this;        } else {          rightChild = subsetEquations.get(thisPosition + 1);        }        if (thisPosition + 1 < subsetEquations.size() - 1) {          subsetEquations.get(thisPosition + 1).buildTreeOn("right");        }      }    }    /**    * Returns true if the operator in this node has precedence over the operator in the specified node.    * The order of precedence is over-ruled by a greater parenthesisLevel number.    * Operator precedence is % greater than /, greather than *, greater than + and -    * + and - have equal precedence to each other.    */    private boolean hasPrecedenceOver(ASTNode node) {      boolean hasPrecedence = false;      try {        if (isNumeric(node.operatorOperand) || isNumeric(operatorOperand)) {          throw new IllegalArgumentException("Problem: hasPrecedenceOver(ASTNode) compares operators - it's receiving an operand");        }        if (parenthesisLevel > node.parenthesisLevel) {          hasPrecedence = true;        } else if (parenthesisLevel == node.parenthesisLevel) {          if (!operatorOperand.equals(node.operatorOperand)) {            if (operatorOperand.equals("%")) {              hasPrecedence = true;            } else if (operatorOperand.equals("/") && !node.operatorOperand.equals("%")) {              hasPrecedence = true;            } else if (operatorOperand.equals("*") && (!node.operatorOperand.equals("%") || !node.operatorOperand.equals("/"))) {              hasPrecedence = true;            }          }        }      } catch (IllegalArgumentException e) {        System.out.println(e.getMessage());      }      return hasPrecedence;    }    @Override    public String toString() {      return "";    }  }}