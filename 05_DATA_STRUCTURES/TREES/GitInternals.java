// cd ~/Desktop/ALL_POOLED/COMPUTING/CODING/JavaExercises/05_DATA_STRUCTURES/TREES// Exercise 9.5. (Introduction to Trees, Sets, interfaces, sorted & unsorted lists)/*'Git internals'In this exercise you will create a simplified representation of a source control treesimilar to the way Git does it.Nodes (commits) in your tree will have three fields: an integer ID, a String description,and a list of parents.This list can be arbitrarily long: use an interface List with only one method, add()(hence, there can be no deletions of parents), then implement it by using pointers orarrays as you did in the exercises of Day 7 (i.e. linked lists).You will need at least two auxiliary pointers to commit nodes, and may have many more(i.e. you will need a list of pointers to commit nodes called something like branchList):HEAD. This pointer points to the current commit (not necessarily the most recent one, see “checkout” and“change branch” below).MASTER (and other branches). Branches are just pointers to commits.Your program should request commands from the user, and act accordingly:Commit.Adds a new commit to the current branch if the current branch and HEAD point to the same commit.If not, nothing happens (except maybe an error message on screen). The ID must be assigned automaticallybut the message is decided by the user. The new commit is linked to its parent (the former HEAD).Checkout.Moves HEAD to point to another commit, as provided by the ID. If the ID does not exist, nothinghappens (except maybe an error message on screen). The current branch does not change.Create branch. Creates a new branch, which means adding a new commit-pointer to the list of pointers (branchList)and make it point to HEAD. The current branch does not change.Change branch.Similar to checkout. Moves HEAD to point to another commit as provided by the branch name.Then changes current branch to that one.Merge.Creates a new commit (with a new ID and new description), whose parents are the current branch andall the other branches provided (by their names). Only works if current branch and HEAD point to the samecommit, otherwise nothing happens (except maybe an error message on screen). The current branch does notchange.The diagrams at http://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging may be of help.*//*** Class which implements the list interface, here with pointers (rather than arrays).*/public class GitInternals implements CommitNodeList {  private CommitNode firstCommit = null;  private List<CommitNode> branchList = new ArrayList<>();  private CommitNode HEAD = null;  public static void main(String[] args) {    do {      System.out.println("enter git command (0 to exit):");      String input = System.console().readLine();      if (input.equals("git commit")) {        HEAD = new CommitNode()        add()      }    } while (Integer.parseInt(input) != 0);  }  @Override  public void add(CommitNode newCommit) {    if (firstCommit == null) {      firstCommit = newCommit;    } else {      firstCommit.add(newCommit);    }  }  /**  * Each commit node as an inner class.  */  private class CommitNode {    private int ID = 0;    private String description = "";    private CommitNodeList parentList = new GitInternals();    // ...methods come here...  }}/****/interface CommitNodeList {  /**  *  */  void add(CommitNode newCommit);}