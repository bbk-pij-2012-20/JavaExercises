// cd ~/Desktop/ALL_POOLED/COMPUTING/CODING/JavaExercises/05_DATA_STRUCTURES/TREES// Exercise 9.5. (Introduction to Trees, Sets, interfaces, sorted & unsorted lists)/*'Git internals'In this exercise you will create a simplified representation of a source control treesimilar to the way Git does it.Nodes (commits) in your tree will have three fields: an integer ID, a String description,and a list of parents.This list can be arbitrarily long: use an interface List with only one method, add()(hence, there can be no deletions of parents), then implement it by using pointers orarrays as you did in the exercises of Day 7 (i.e. linked lists).You will need at least two auxiliary pointers to commit nodes, and may have many more(i.e. you will need a list of pointers to commit nodes called something like branchList):HEAD. This pointer points to the current commit (not necessarily the most recent one,see “checkout” and “change branch” below).MASTER (and other branches). Branches are just pointers to commits.Your program should request commands from the user, and act accordingly:CommitAdds a new commit to the current branch if the current branch and HEAD point to the same commit.If not, nothing happens (except maybe an error message on screen). The ID must be assignedautomatically but the message is decided by the user.The new commit is linked to its parent (the former HEAD).CheckoutMoves HEAD to point to another commit, as provided by the ID. If the ID does not exist, nothinghappens (except maybe an error message on screen). The current branch does not change.Create branchCreates a new branch, which means adding a new commit-pointer to the list of pointers (branchList)and make it point to HEAD. The current branch does not change.Change branchSimilar to checkout. Moves HEAD to point to another commit as provided by the branch name.Then changes current branch to that one.MergeCreates a new commit (with a new ID and new description), whose parents are the current branch andall the other branches provided (by their names). Only works if current branch and HEAD point tothe same commit, otherwise nothing happens (except maybe an error message on screen).The current branch does not change.*///It may be of help to look at the diagrams at http://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Mergingimport java.util.List;import java.util.ArrayList;/*** Class which implements the list interface, here with pointers (rather than arrays).*/public class GitInternals  extends CommitNodeList {  private List<CommitNode> branchList = new ArrayList<>();  private CommitNode HEAD = null;  private CommitNode MASTER = null;  private CommitNode currentBranch = null;  private List<CommitNode> stagedNodes = null;  public static void main(String[] args) {    CommitNodeList git = new GitInternals();    String input = "";    do {      System.out.println("enter git command, 0 to exit:");      System.out.print("git ");      input = System.console().readLine().trim();      git.process(input);    } while (!input.equals("0"));    git.add();  }  /**  * Constructor  */  public GitInternals() {    branchList.add(0, HEAD);    branchList.add(1, MASTER);    branchList.add(2, currentBranch);  }  @Override  public void add() {    System.out.println("..adding a new commit node to staging area");    CommitNode newNode = new CommitNode();    setId(getMostRecentId);    stagedNodes.add(newNode);  }  public int getMostRecentId() {    return stagedNodes.get(stagedNodes.indexOfLast().ID);  }  /**  *  */  public void changeBranch(String input) {  }  /**  *  */  public void checkout(String input) {  }  /**  * Makes a new commit or gives error message.  */  public void commit(String input) {    String input_ = input.trim().toLowerCase();    try {      if (!input_.substring(0,6).equals("commit")) {        throw new IllegalArgumentException("Commit command text incorrectly entered. Did you forget to include \"-m\'message\'\" ?");      }    } catch (IllegalArgumentException e) {      System.out.println(e.getMessage());    }    try {      if (HEAD == null) {        HEAD = newCommit;      } else if (HEAD != currentBranch) {        throw new IllegalArgumentException("cannot add new commit to current branch as this not currently the same as the HEAD");      } else {        newCommit.parentList.add(HEAD);        HEAD = newCommit;      }    } catch (IllegalArgumentException e) {      System.out.println(e.getMessage());    }  }  /**  * Extracts the description text following git commit (after -m and between '').  * It receives the text trimmed and throws an exception if not of the format -m 'text'  */  public String extractDescriptionFrom(String commitInput) {    String commitInputAfter_m = commitInput.substring(2).trim();    String description = "";    try {      if (!commitInput.substring(0,2).equals("-m") || commitInput.length() < 6 || commitInput.substring(commitInput.length() - 1) != "'") {        throw new IllegalArgumentException("The format of the description is not correct.");      }      if (!commitInputAfter_m.substring(0,1).equals("'")) {        throw new IllegalArgumentException("The format of the description is not correct.");      }      description = commitInputAfter_m.substring(0);    } catch (IllegalArgumentException e) {      System.out.println(e.getMessage());    }    return description;  }  /**  *  */  private void merge(String input) {  }  /**  * Processes commands from the user.  */  private void process(String input) {    switch (input.substring(0, 5)) {      case "commi" : commit(input); break;      case "check" : checkout(input); break;      case "chang" : changeBranch(input); break;      case "merge" : merge(input); break;      default : System.out.println("I do not recognise this command"); break;    }  }  /**  * Each commit node as an inner class.  */  protected class CommitNode {    private int ID = 0;    private String description = "";    private CommitNodeList parentList = new GitInternals();    /**    * Constructor    */    private CommitNode() {      this.description  = description;      this.ID = ID;    }  }}/*** Interface that is implemented by GitInternals*/interface CommitNodeList {  /**  * Adds new commit node to staging area (before 'git commit' command is issue)  */  void add();}